## Предыстория

Команда уже запустила клиентский HyperSniper Bot (telegram mini-app + backend), который отвечает за UX: отображение новых токенов, управление кошельками, фильтры и быстрые действия пользователей. Этот бот опирается на сторонние источники данных и постепенно упирается в задержку ~6–8 секунд между реальным деплоем JettonMinter и появлением сигнала в интерфейсе. Чтобы выйти в топ-1 % по скорости и контролировать полный стек, требуется вынести индексацию блокчейна TON в отдельный высокопроизводительный сервис — HyperSniper-Indexer. Новая система должна автономно получать сырые блоки TON, обрабатывать их с задержкой не более 2 секунд и в реальном времени пушить события в шину (TG-бот, webhook, downstream-сервисы). Настоящее ТЗ описывает именно этот индексатор, но тесно увязывает его с уже работающей оболочкой HyperSniper Bot, чтобы сохранить контекст при запуске отдельного репозитория.

## Проект: HyperSniper-Indexer

Полностью автономный индексатор сети TON, который ловит новые JettonMinter’ы (деплой новых токенов) с минимально возможной задержкой (цель — 1–2 секунды после включения в блок).

### Ключевые цели

- Задержка обнаружения нового JettonMinter — не более 2 секунд после включения транзакции в блок (ориентир — 1–1.5 сек).
- Покрытие 100 % шардов и воркчейнов без пропусков.
- Автоматическое определение JettonMinter по `code_hash` (минимум 6 актуальных хэшей стандартов 2024–2025: ton-org, broxus, old-standard и др.).
- При обнаружении: мгновенный вывод в консоль + отправка в Telegram-канал/чат (через бот) + опциональный webhook.
- Масштабируемость под дальнейшее добавление автопокупки через несколько кошельков, анти-MEV защиты и т.п.
- Полная автономность: работа 24/7 на одном VPS без внешних платных API.

### Выбранный стек

- Язык: Go 1.23+
- Индексатор: `ton-org/ton-indexer` (встроенный как библиотека)
- Хранилище блоков: PostgreSQL (тон-индексер)
- Кэш: Redis (последние блоки и найденные минтеры)
- TON клиент: `tonlib-go` или `mytonctrl` при необходимости получения raw-блоков
- Liteserver: публичные из `https://ton.org/global-config.json`, затем выделенный
- Конфигурация: env + `config.yaml`
- Логи: `zap` или `logrus` (структурированные, комментарии на русском)

## Структура репозитория

```
hyper-sniper-indexer/
├── cmd/
│   └── indexer/
│       └── main.go
├── internal/
│   ├── config/
│   ├── indexer/
│   ├── processor/
│   ├── detector/
│   ├── notifier/
│   ├── storage/
│   └── utils/
├── pkg/
│   └── ton/
├── scripts/
│   ├── install_deps.sh
│   └── setup_liteserver.sh
├── docker/
│   ├── Dockerfile
│   └── docker-compose.yml
├── config.yaml
├── go.mod
├── go.sum
├── README.md          # кратко, только на английском
└── ИНСТРУКЦИЯ_ПО_ЗАПУСКУ.md  # подробно, на русском
```

## Дорожная карта (обязательные шаги, каждый — отдельный коммит)

1. **Инициализация проекта**  
   Создать репозиторий, `go mod init github.com/yourname/hyper-sniper-indexer`, развернуть структуру папок, `.gitignore`, `go.mod` с зависимостями.

2. **Конфигурация и env**  
   `internal/config` — загрузка `config.yaml` + env. Обязательные поля: `postgres_dsn`, `redis_addr`, `tg_bot_token`, `tg_chat_id`, `webhook_url`, `liteservers_list` (массив).

3. **Запуск ton-indexer как встроенного сервиса**  
   Использовать `ton-indexer` как библиотеку, подключаться к публичным liteserver’ам, запускать полную синхронизацию с нуля.

4. **Подписка на новые транзакции в реальном времени**  
   `SubscribeToTransactions` (или аналог), обрабатывать только внешние сообщения `in_msg` с деплоем контракта.

5. **Детектор JettonMinter**  
   Список актуальных `code_hash` (минимум 6, декабрь 2025). При появлении нового аккаунта — `getCodeHash`, сравнить, при совпадении — `runGetMethod` для метаданных (`name`, `symbol`, `decimals`).

6. **Redis-кэш**  
   Хранить последние 1000 обработанных `seqno` мастерчейна и найденные минтеры, чтобы исключить дубли.

7. **Notifier**  
   Форматированное сообщение в TG (название токена, тикер, адрес, ссылка на tonviewer, время), webhook JSON, цветной консольный вывод (`aurora` или `fatih/color`).

8. **Полная синхронизация + исторические данные**  
   Режим `catchup`: вывести всех минтеров за последние 24 часа.

9. **Docker + docker-compose**  
   Compose: PostgreSQL, Redis, приложение. ton-indexer запускается и синхронизируется автоматически.

10. **ИНСТРУКЦИЯ_ПО_ЗАПУСКУ.md**  
    Подробная инструкция на русском: установка Go/Docker/PostgreSQL, получение TG bot token, запуск `docker-compose up --build`, ожидание синка (логи), тест — деплой минтера в testnet, переход на выделенный liteserver, мониторинг задержки (сравнение с tonviewer).

11. **Финальные шаги**  
    Graceful shutdown, обработка ошибок и reconnect’ов, опциональный Prometheus endpoint, unit-тесты для detector и processor.

## Требования к реализации

- Все комментарии — только на русском языке.
- Английские имена переменных и функций (snake_case).
- Каждый файл ≤ 400 строк.
- Логика строго разделена по пакетам.
- Никаких магических чисел — использовать константы.
- Максимальная производительность: goroutines, worker pool по шардам.
- Автономная работа 24/7 на VPS, без платных API.

## Связь с существующим HyperSniper Bot

- Индексатор публикует события о новых JettonMinter’ах в Telegram (тот же бот), а также в webhook, который текущий бекенда бота может слушать.
- Для минимальной задержки HyperSniper Bot должен доверять событиям индексатора и не применять собственный polling.
- Планируемое расширение: бот сможет инициировать сделки, используя индексатор как источник истины (через webhook/queue/gRPC). Поэтому интерфейсы между системами должны быть простыми и документированными.

## Финальный результат

- zip-архив репозитория после выполнения всех шагов.
- Финальное сообщение: «ГОТОВО. Проект полностью рабочий, задержка 1–2 сек на выделенном liteserver’е».

